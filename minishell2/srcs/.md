# Minishell

## 허용 함수
	readline ,rl_clear_history, rl_on_new_line,
	rl_replace_line, rl_redisplay, add_history,
	printf, malloc, free, write, access, open, read,
	close, fork, wait, waitpid, wait3, wait4, signal,
	sigaction, sigemptyset, sigaddset, kill, exit,
	getcwd, chdir, stat, lstat, fstat, unlink, execve,
	dup, dup2, pipe, opendir, readdir, closedir,
	strerror, perror, isatty, ttyname, ttyslot, ioctl,
	getenv, tcsetattr, tcgetattr, tgetent, tgetflag,
	tgetnum, tgetstr, tgoto, tputs

	libft사용 가능
___

## 함수 정리
readline

	#include <readline/readline.h>

	char *readline(const char *str);

	str을 출력하고 프롬프트를 열어서 표준 입력으로 문자열을 입력받는다.
	개행(엔터)를 받으면 지금까지 입력된 문자열을 리턴한다.
	문자열을 입력받기 전까지는 다음 코드로 진행되지 않는다.
	반환된 문자열은 사용이 끝난후 free를 사용해서 메모리를 해제 해주어야한다.

```c
#include <readline/readline.h>
#include <stdio.h>
#include <strlib.h>

int	main()
{
	char *input = readline("명령어 입력: ");
	printf("입력된 명령어: %s\n", input);
	free(input);
	return (0);
}
```
____

rl_clear_history

	#include <readline/history.h>
	void	rl_clear_history(void);

	현재까지 누적된 명령어 히스토리를 삭제 합니다.
	이 함수 호출 후에는 이전에 입력된 명령어들이 히스토리에서 완전이
	제거되어 더 이상 접근할 수 없게 됩니다.

```c
#include <readline/history.h>

int	main()
{
	char *input = readline("Enter command: ");
	add_history(input);

	input = readline("Enter next command: ");
	add_hostory(input);

	HIST_ENTRY **the_history = history_list();
	if (the_history)
	{
		for (int i = 0; teh_history[i]; i++)
			printf("%d: %s\n", i + history_base,
				the_history[i]->line);
	}

	rl_clear_history();
	free(input);
	return (0);
}
```
___
 rl_on_new_line

	#include <readline/readline.h>
	void	rl_on_new_line(void);

	readline이 새로운 입력 줄을 시작할 준비가 되었음을
	readline라이브러리에 알리는데 사용된다, 이 함수는
	사용자가 새 줄에 입력을 시작하기 전에 내부 readline 상태를 올바르게
	재설정하고, 화면 상에 적절하게 표시 될 수 있도록 한다
	rl_on_new_line은 특히 여러 줄에 걸친 입력을 처리하거나, 동적인
	출력과 사용자 입력이 혼합되는 상황에서 사용한다.

```c
#include <stdio.h>
#include <readline/readline.h>
#include <readline/hostory.h>

void	custom_print_func()
{
	printf("Custom message before user input.\n");
	rl_on_new_line(); // readline에게 새 줄에서 입력을 시작할 준비가 되었음을 알림
}

int main()
{
	custom_print_func(); // 사용자 입력 전에 커스텀 메세지 출력

	// 사용자로부터 입력 받기
	char *input = readline("Enter your command: ");
	add_history(input); // 입력된 명령어를 히스토리에 추가

	free(input);
	return (0);
}
```
___

rl_replace_line

	#include <readline/readline.h>
	void	rl_reaplace_line(const char *text, int clear_undo);

	현재 사용자가 입력 중인 텍스트 라인을 지정된 텍스트로 교체하는데 사용된다,
	이 함수는 스크립트나 프로그램이 사용자 입력을 동적으로 수정하거나 조정할
	필요가 있는 경우에 유용하다, 예를 들어 사용자 입력을 기반으로 자동 완성 기능을 구현하거나,
	특정 조건을 만족하는 경우 사용자의 입력을 프로그램 측에서 변경해야 할 때 사용할 수 있다.

	clear_undo 가 0이 아닌 값이면 히스토리를 클리어 한다.

```c
#include <readline/readline.h>
#include <readline/history.h>
#include <stdio.h>

int main()
{
	// readline 프롬프트 표시 및 사용자 입력 받기.
	char *input = readline("Enter your command: ");

	// 사용자 입력을 'New text'로 교체하기.
	rl_replace_line("New text", 1); // Undo 히스토리도 클리어

	// 수정된 라인을 화면에 다시 표시하기
	rl_redisplay();

	// 후속 작업 (예: 메모리 해제)
	free(input);
	return (0);
}
```

___
rl_redisplay

	#include <readline/readline.h>
	void	rl_redisplay(void);

	사용자 인터페이스의 현재 상태를 화면에 다시 그리는 데 사용된다.

```c
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

int main()
{
	char *input = readline("Enter your command: ");
	rl_replace_line("MOdifind text", 1);

	rl_redisplay(); // 위에서 replace로 변경한 사항을 바로 화면에 반영
	free(input);
	return (0);
}
```
___

add_history

	#include <readline/history.h>
	void add_history(const char *line);

	사용자가 입력한 명령어 또는 텍스트를 히스토리 목록에 추가하는 데 사용된다,
	이 기능은 이전에 실행한 명령어들을 쉽게 다시 호출하고 사용할 수 있게 한다

```c
#include <stdio.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <readline/history.h>

int main()
{
	char *input = readline("Enter your command: ");
	if (input && *input)
		add_history(input);

	printf("Your entered: %s\n", input);
	free(input);
	return (0);
}

```
___
access

	#include <unstdi.h>
	int access(const char *pathname, int mode);
	pathname: 접근 권한을 검사하고자 하는 파일 또는 디렉토리 경로.
	mode: 검사하고자 하는 접근 권한의 유형.
	F_OK는 파일 존재 여부만 검사,
	R_OK는 파일 읽기 권한
	W_OK는 파일 쓰기 권한
	X_OK는 파일 실행 권한

	return value
	성공 시 : 0
	실패 시 : -1 을 반환하고 errno에 오류코드를 설정

```c
#include <stdio.h>
#include <unistd.h>
#include <errno.h>

int main()
{
	const char *filepath = "/path/to/file.txt";

	// 파일 존재 여부 검사
	if (access(filepath, F_OK) == 0)
		printf("File exists.\n");
	else
		printf("File does not exist.\n");

	// 파일 읽기 권한 검사
	if (access(filepath, R_OK) == 0)
		printf("Read permission is granted.\n");
	else
		printf("Read permission is denied.\n");
	return (0);
}
```
___
wait3, wait4

	#include <sys/type.h>
	#include <sys/wait.h>
	#include <sys/resource.h>
	pid_t wait3(int *status, int options, struct rusage *rusage);

	status: 자식 프로세스의 종료 상태를 저장하는 포인터입니다. 이 값을 통해 자식
	프로세스가 어떻게 종료되었는지(예: 정상 종료, 시그널에 의한 종료 등) 알 수 있습니다.

	options: waitpid 함수와 유사하게,wait3 호출의 동작을 제어하는 옵션입니다.
	WNOHANG, WUNTRACED 등의 플래그를 사용할 수 있습니다.

	rusage: 자식 프로세스에 의해 소비된 리소스 사용량을 저장하는 struct rusage 구조체의 포인터입니다.

	pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);
	pid: 특정 자식 프로세스를 대상으로 할 때, 그 프로세스의 PID를 지정합니다.
	wait3와는 달리, 특정 PID나 프로세스 그룹을 지정할 수 있는 기능을 제공합니다.

	status: wait3와 마찬가지로, 자식 프로세스의 종료 상태를 저장하는 포인터입니다.
	options: wait3에서 설명된 것과 같은 옵션을 지정합니다.
	rusage: wait3와 동일하게, 자식 프로세스의 리소스 사용 정보를 저장합니다.
